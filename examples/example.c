/******************************************************************************
Finite State Machine
Project: sm.dot
Description: <none given>

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.2.1
Generation date: 2020-08-31 12:03:07 +0200
Generated from: sm.dot
The finite state machine has:
  5 states
  5 transition functions
Functions and types have been generated with prefix "fsm_"
******************************************************************************/

#include <syslog.h>
#include "example.h"

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

//  ____  _        _       
// / ___|| |_ __ _| |_ ___ 
// \___ \| __/ _` | __/ _ \
//  ___) | || (_| | ||  __/
// |____/ \__\__,_|\__\___|
//                         
//   __                  _   _                 
//  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
// | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
// |  _| |_| | | | | (__| |_| | (_) | | | \__ \
// |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
//                                             

// Function to be executed in state init
// valid return states: FSM_STATE_IDLE
fsm_state_t fsm_do_init(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_STATE_IDLE;

  syslog(LOG_INFO, "[FSM] In state init");
  /* Your Code Here */
  
  
  switch (next_state) {
    case FSM_STATE_IDLE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from init to %s, remaining in this state", state_names[next_state]);
      next_state = FSM_NO_CHANGE;
  }
  return next_state;
}


// Function to be executed in state idle
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_SETUP
fsm_state_t fsm_do_idle(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;

  syslog(LOG_INFO, "[FSM] In state idle");
  /* Your Code Here */
  
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_SETUP:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from idle to %s, remaining in this state", state_names[next_state]);
      next_state = FSM_NO_CHANGE;
  }
  return next_state;
}


// Function to be executed in state setup
// valid return states: FSM_STATE_RUNNING
fsm_state_t fsm_do_setup(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_STATE_RUNNING;

  syslog(LOG_INFO, "[FSM] In state setup");
  /* Your Code Here */
  
  
  switch (next_state) {
    case FSM_STATE_RUNNING:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from setup to %s, remaining in this state", state_names[next_state]);
      next_state = FSM_NO_CHANGE;
  }
  return next_state;
}


// Function to be executed in state running
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_RUNNING, FSM_STATE_STOP
fsm_state_t fsm_do_running(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;

  syslog(LOG_INFO, "[FSM] In state running");
  /* Your Code Here */
  
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_RUNNING:
    case FSM_STATE_STOP:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from running to %s, remaining in this state", state_names[next_state]);
      next_state = FSM_NO_CHANGE;
  }
  return next_state;
}


// Function to be executed in state stop
// valid return states: FSM_NO_CHANGE
fsm_state_t fsm_do_stop(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;

  syslog(LOG_INFO, "[FSM] In state stop");
  /* Your Code Here */
  
  
  switch (next_state) {
    case FSM_NO_CHANGE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from stop to %s, remaining in this state", state_names[next_state]);
      next_state = FSM_NO_CHANGE;
  }
  return next_state;
}


//  _____                    _ _   _              
// |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
//   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
//   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
//   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
//                                                
//   __                  _   _                 
//  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
// | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
// |  _| |_| | | | | (__| |_| | (_) | | | \__ \
// |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
//    
                                         
// This function is called in 1 transition:
// 1. from init to idle
void fsm_init_to_idle(fsm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition fsm_init_to_idle");
  /* Your Code Here */
}

// This function is called in 2 transitions:
// 1. from idle to idle
// 2. from running to running
void fsm_stay(fsm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition fsm_stay");
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to setup
void fsm_to_setup(fsm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition fsm_to_setup");
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from setup to running
void fsm_setup_to_running(fsm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition fsm_setup_to_running");
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from running to idle
void fsm_to_idle(fsm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition fsm_to_idle");
  /* Your Code Here */
}


//  ____  _        _        
// / ___|| |_ __ _| |_ ___  
// \___ \| __/ _` | __/ _ \
//  ___) | || (_| | ||  __/ 
// |____/ \__\__,_|\__\___| 
//                          
//                                              
//  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
// | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
// | | | | | | (_| | | | | (_| | (_| |  __/ |   
// |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
//                              |___/           

fsm_state_t fsm_run_state(fsm_state_t cur_state, fsm_state_data_t *data) {
  fsm_state_t new_state = fsm_state_table[cur_state](data);
  transition_func_t *transition = fsm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state == FSM_NO_CHANGE ? cur_state : new_state;
};


#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  fsm_state_t cur_state = FSM_STATE_INIT;
  openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
  syslog(LOG_INFO, "Starting SM");
  do {
    cur_state = fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != FSM_STATE_STOP);
  return 0;
}
#endif
